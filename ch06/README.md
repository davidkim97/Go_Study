# Golang

## Chapter 06.

## 연산자

### 1. 산술 연산자

- 모든 연산자의 각 항의 타입은 항상 같아야 한다.(시프트 연산 제외)

- 비트 연산자

  - &(AND 연산자)
    |A|B|A&B|
    |---|---|---|
    |0|0|0|
    |1|0|0|
    |0|1|0|
    |1|1|1|

  - |(OR 연산자)
    |A|B|A\|B|
    |---|---|---|
    |0|0|0|
    |1|0|1|
    |0|1|1|
    |1|1|1|

  - ^(XOR 연산자)
    |A|B|A^B|
    |---|---|---|
    |0|0|0|
    |1|0|1|
    |0|1|1|
    |1|1|0|

  - &^(비트 클리어 연산자)
    - 특정 비트를 0으로 바꾸는 연산자이다.
    - 우변값에 해당하는 비트를 클리어 하는 연산자이다.
    - ^를 먼저 수행 후 & 수행

- 시프트 연산자

  1. <<(왼쪽 시프트)

  - 오른쪽 피연산자값 만큼 전체 비트를 왼쪽으로 밀어낸다.

  - 비트가 이동되어 빈 자리는 0이 채워지고, 자릿수를 벗어난 비트는 버려진다.

  2. \>\> (오른쪽 시프트)

  - 비트값을 오른쪽으로 밀어낸다.

  - 비트 수를 나타내는 오른쪽 피연산자는 반드시 양의 정수여야 한다.

  - 부호있는 정수이면 왼쪽 비트에 부호와 같은 값으로, 부호가 없는 정수이면 0으로 채워진다.

  - 음수이면 최상위 비트가 1이므로 1로, 양수이면 0으로 채워진다.

- 비교 연산자

  - 양변을 비교해서 조건에 만족하면 true, 아니면 false 반환

    | 연산자 | 설명        |
    | ------ | ----------- |
    | ==     | 같다        |
    | !=     | 다르다      |
    | <      | 작다        |
    | >      | 크다        |
    | <=     | 작거나 같다 |
    | >=     | 크거나 같다 |

  - 비교 연산자는 분기문(if문, switch문)과 반복문(for문)에서 주로 사용한다.

    | 비교연산자 | 연산 의미      | 결과  |
    | ---------- | -------------- | ----- |
    | 2==2       | 같은가?        | true  |
    | 2!=2       | 같지 않은가?   | false |
    | 3<2        | 작은가?        | false |
    | 4.2>1.3    | 큰?            | true  |
    | 2<=2       | 작거나 같은가? | true  |
    | 5>=8       | 크거나 같은가? | false |

  - 비교 연산자를 사용할 때 주의할점.

    - 정수 오버플로우

    - 정수 언더플로우

    - 실수끼리 비교

- 정수 오버플로우

  - 정수가 정수 타입의 범위를 벗어난 경우 값이 비정상으로 변화하는 현상을 오버플로우(overflow)라고 한다.

- 정수 언더플로우

  - 오버플로우와 반대로 정수 타입이 표현할 수 있는 가장 작은 값에서 -1을 했을 때는 가장 큰 값으로 바뀐다.

- 정수 타입은 값의 경계에서 오버플로우, 언더플로우가 발생하기 때문에 연산 할 때 항상 경계값에 주의해야 한다.

- float 비교 연산

  - 실수끼리의 == 연산에서 예기치 않은 결과가 나올 때가 있다.

  ```Go
  package main

  import "fmt"

  func main() {
    var a float64 = 0.1
    var b float64 = 0.2
    var c float64 = 0.3

    fmt.Printf("%f + %f == %f : %v\n", a, b, c, a+b == c)
    fmt.Println(a + b)
  }

  /* 결과
    0.100000 + 0.200000 == 0.300000 : false
    0.30000000000000004
  */
  ```

- 실수 오차

  - 컴퓨터는 지수부와 소수부가 10진수 기준이 아니라 2진수 기준으로 되어 있어 10진수 실수를 정확히 표현하기 어렵다.

  - 작은 오차는 무시하는 방법으로 값을 비교할 수 있다.

  ```Go
  package main

  import "fmt"

  const epsilon = 0.000001 // 매우 작은 값

  func equal(a, b float64) bool {
    if a > b {
      if a-b <= epsilon { // 작은 차이 무시
        return true
      } else {
        return false
      }
    } else {
      if b-a <= epsilon {
        return true
      } else {
        return false
      }
    }
  }

  func main() {
    var a float64 = 0.1
    var b float64 = 0.2
    var c float64 = 0.3

    fmt.Printf("%0.18f + %0.18f = %0.18f\n", a, b, a+b)
    fmt.Printf("%0.18f == %0.18f : %v\n", c, a+b, equal(a+b, c))

    a = 0.0000000000004
    b = 0.0000000000002
    c = 0.0000000000007

    fmt.Printf("%g == %g : %v\n", c, a+b, equal(a+b, c))
  }

  /* 결과
      0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044
      0.299999999999999989 == 0.300000000000000044 : true
      7e-13 == 6.000000000000001e-13 : true
  */
  ```

  - 오차를 없애는 더 나은 방법

    - 가장 간편하고 좋은 방법은 1비트 차이만큼 비교하는 것이다.

    - Go에는 math 패키지에서 Nextafter() 함수를 제공한다.

  ```Go
  package main

  import (
    "fmt"
    "math"
  )

  func equal(a, b float64) bool {
    return math.Nextafter(a, b) == b
  }

  func main() {
    var a float64 = 0.1
    var b float64 = 0.2
    var c float64 = 0.3

    fmt.Printf("%0.18f + %0.18f = %0.18f\n", a, b, a+b)
    fmt.Printf("%0.18f == %0.18f : %v\n", c, a+b, equal(a+b, c))

    a = 0000000000004
    b = 0000000000002
    c = 0000000000007

    fmt.Printf("%g == %g : %v\n", c, a+b, equal(a+b, c))
  }

  /* 결과
    0.100000000000000006 + 0.200000000000000011 = 0.300000000000000044
    0.299999999999999989 == 0.300000000000000044 : true
    7 == 6 : false
  */
  ```

- 논리 연산자

  - 불리언 피연산자를 대상으로 연산해 결과로 true, false를 반환한다.

  | 연산자 | 연산자명 | 설명                                      |
  | ------ | -------- | ----------------------------------------- |
  | &&     | AND      | 양변이 모두 true면 true를 반환            |
  | \|\|   | OR       | 하나라도 true면 true 반환                 |
  | !      | NOT      | true이면 false를 반환, false이면 true반환 |

  - &&(AND 논리 연산자)
    |A|B|A&&B|
    |---|---|---|
    |false|false|false|
    |true|false|false|
    |false|true|false|
    |true|true|true|

  - || (OR 논리 연산자)
    |A|B|A\|\|B|
    |---|---|---|
    |false|false|false|
    |true|false|true|
    |false|true|true|
    |true|true|true|

  - ! (NOT 논리 연산자)
    |A|!A|
    |---|---|
    |false|true|
    |true|false|

- 대입 연산자

  - = 대입 연산자는 우변값을 좌변(메모리 공간)에 복사한다.  
    좌변은 반드시 저장할 공간이 있는 변수가 와야 한다.

  - 증감 연산자

    - ++ : 정수 타입 변수 뒤에 붙여쓰며, 해당 변수값을 1증가
    - -- : 정수 타입 변수 뒤에 붙여쓰며, 해당 변수값을 1감소

    ```Go
    var a int = 10

    // 아래 세 구문 모두 a 값을 1 증가 시킨다.
    a = a + 1
    a += 1
    a++

    // 아래 세 구문 모두 a 값을 감소 시킨다.
    a = a - 1
    a -= 1
    a--
    ```

  - 그 외 연산자
    |연산자|설명|
    |---|---|
    |[]|배열의 요소에 접근할 때|
    |.|구조체나 패키지 요소에 접근할 때|
    |&|변수의 메모리 주소 값을 반환 함|
    |\*|포인터 변수가 가리키는 메모리 주소에 접근|
    |...|슬라이스 요소들에 접근하거나 가변 인수를 만들 때|
    |:|배열의 일부분을 집어올 때|
    |<-|채널에서 값을 빼거나 넣을 때|

  - 연산자 우선순위
    |우선순위|연산자|
    |---|---|
    |5|\* / % << >> & &^|
    |4|+ - \| ^ |
    |3|== != < <= > >=|
    |2|&&|
    |1|\|\||

### 핵심 요약

1. 산술 연산자로는 사칙 연산, 비트 연산, 시프트 연산이 있다.

2. 정수 타입으로 값의 경계에서 연산할 때는 항상 주의해야 한다.

3. 실수 타입은 서로 값이 같은지 비교하는 == 연산자가 비정상 동작 할 수 있다.

4. 비교 연산자와 논리 연산자를 결합하여 다양한 조건을 만들 수 있다.

5. 대입 연산자는 값을 반환하지 않는다.

6. 복합 대입 연산자를 사용하면 연산을 간편하게 줄여 쓸 수 있다.
